# 의존성 주입의 이해
의존성 주입을 적절하게 사용하면 코드를 테스트할 수 있게 만드는 방법을 알수 있다.

1. 데이터 서비스와 통신하는 비즈니스 서브스의 간단한 예를 작성하라. 비즈니스 서비스가 데이터 서비스의 인스턴스를 직접 생성하면 서로 밀접하게 결합된다. 단위 테스트는 어려울 것이다.
2. 데이터 서비스를 생성하는 책임을 비즈니스 서비스 밖으로 이동시켜 코드를 느슨하게 결합하라.
3. 스프링 IoC 컨테이너를 가져와 빈을 인스턴스화 하고 서로 연결하라
4. 스프링이 제공하는 XML 및 자바 구성 옵션을 살펴보라
5. 스프링 단위 테스트 옵션을 살펴보라
6. 모킹을 사용해 실제 단위 테스트를 작성하라

## 의존성 주입이 필요한 이유
```java
public class Store {
    private Pencil pencil;
    
    public Store(){
        this.pencil = new Pencil();
    }
}
```

위와 같은 예시는 다음과 같은 문제점이 있음
- 두 클래스가 강하게 결합되어 있음
  - 위와 같은 Store 클래스는 현재 Pencil 클래스와 강하게 결합되어 있다는 문제점을 가지고 있다. 
  - 두 클래스가 강하게 결합되어 있어서 만약 Store에서 Pencil이 아닌 Food와 같은 다른 상품을 판매하고자 한다면 Store 클래스의 생성자에 변경이 필요하다. 
  - 즉, 유연성이 떨어진다. 각각의 다른 상품들을 판매하기 위해 생성자만 다르고 나머지는 중복되는 Store 클래스들이 파생되는 것은 좋지 못하다. 
  - 이에 대한 해결책으로 상속을 떠올릴 수 있지만, 상속은 제약이 많고 확장성이 떨어지므로 피하는 것이 좋다.
    

- 객체들 간의 관계가 아니라 클래스 간의 관계가 맺어짐
  - 위의 Store와 Pencil는 객체들 간의 관계가 아니라 클래스들 간의 관계가 맺어져 있다는 문제가 있다.
  - 올바른 객체지향적 설계라면 객체들 간에 관계가 맺어져야 한다.
  - 객체들 간에 관계가 맺어졌다면 다른 객체의 구체 클래스(Pencil인지 Food 인지 등)를 전혀 알지 못하더라도, (해당 클래스가 인터페이스를 구현했다면) 인터페이스의 타입(Product)으로 사용할 수 있다.



## 의존성 주입을 통한 문제 해결
```java
public interface Product {
    
}

public class Pencil implements Product {
    
}

public class Store {
    private Product product;
    
    public Store(Product product){
        this.product = product;
    }
}
```

이러한 이유로 우리는 Spring이라는 DI 컨테이너를 필요로 하는 것이다.
Store에서 Product 객체를 주입하기 위해서는 애플리케이션 실행 시점에 필요한 객체(빈)를 생성해야 하며, 의존성이 있는 두 객체를 연결하기 위해 한 객체를 다른 객체로 주입시켜야 한다.


```java
public class BeanFactory {

    public void store() {
        // Bean의 생성
        Product pencil = new Pencil();
    
        // 의존성 주입
        Store store = new Store(pencil);
    }
    
}
```

한 객체가 어떤 객체(구체 클래스)에 의존할 것인지는 별도의 관심사이다. 
Spring은 의존성 주입을 도와주는 DI 컨테이너로써, 강하게 결합된 클래스들을 분리하고, 애플리케이션 실행 시점에 객체 간의 관계를 결정해 줌으로써 결합도를 낮추고 유연성을 확보해준다. 
이러한 방법은 상속보다 훨씬 유연하다. 단, 한 객체가 다른 객체를 주입받으려면 반드시 DI 컨테이너에 의해 관리되어야 한다는 것이다.